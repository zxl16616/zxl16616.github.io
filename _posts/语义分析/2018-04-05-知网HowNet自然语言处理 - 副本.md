---
layout: post
comments: true
categories: 自然语言处理
---

###1.本体的结构
OWL是语义网活动的一个组成部分。这项工作的目的是通过对增加关于那些描述或提供网络内容的资源的信息，从而使网络资源能够更容易地被那些自动进程访问。由于语义网络固有的分布性，OWL必须允许信息能够从分布的信息源收集起来。其中，允许本体间相互联系，包括明确导入其他本体的信息，能够部分实现这样的功能。  

另外，OWL提出了一个开放世界的假设。也就是说，对资源的描述并不局限于在一个简单的文件或范围内。类C1本来是由本体O1定义出来的，然而，它也可以是由其他的本体扩展出来的。对C1进行这样的假设的结果是单调的。新的信息不能否定之前的信息。新的信息可以是和旧的信息矛盾的，但是事实和推导只能被增加而不能被删减。 

当设计一个本体的时候，设计者必须考虑到这种矛盾的可能性。一种期望是，工具的支持将帮助侦测到这样的情况。  

为了能写出一个能被唯一翻译的而且能被软件（代理）使用的本体，我们要求OWL有一个语法和正规的语义。


###2.命名空间
<rdf:RDF   
   xmlns     ="http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#"   
   xmlns:vin ="http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#"   
   xml:base  ="http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#"   
   xmlns:food="http://www.w3.org/TR/2004/REC-owl-guide-20040210/food#"   
   xmlns:owl ="http://www.w3.org/2002/07/owl#"  
   xmlns:rdf ="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"  
   xmlns:xsd ="http://www.w3.org/2001/XMLSchema#">  

前两个声明标识了与该本体相关的命名空间。第一个声明指定了缺省命名空间，即表明所有无前缀的限定名（qualified names）都出自当前本体。第二个声明为当前本体指定了前缀 vin:。第三个声明为当前文档（参见下文 (http://www.w3.org/TR/2004/REC-owl-guide-20040210/#owl_imports)）指定了基准URI（base URI）。第四个声明指出食物（food）本体将用前缀food:来标识。第五个命名空间声明指出，在当前文档中，前缀为owl:的元素应被理解是对出自http://www.w3.org/2002/07/owl#中的事物的引用。这是引入OWL词汇表的惯例用法。  

OWL要依赖RDF、RDFS以及XML Schema数据类型中的构词（constructs）。在本文档中，rdf:前缀表明事物出自命名空间http://www.w3.org/1999/02/22-rdf-syntax-ns#。接下来的两个命名空间声明分别为RDF Schema和XML Schema数据类型指定前缀rdfs:和xsd:。


###3.实体定义
为帮助书写冗长的URLs，在本体的定义之前，在文档类型声明（DOCTYPE）中提供一些实体定义（entity definitions）常常是很有用的。这些被命名空间声明定义的名称仅当作为XML标签的一部分时才具有意义。属性值（attribute values）是不具有命名空间的。但是在OWL里，我们经常要用属性值来引用本体标识符。我们可以写出它们的完整URI形式，比如“http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#merlot”。或者，利用实体定义来简略URI的书写，例如：  

 <!DOCTYPE rdf:RDF [  
   <!ENTITY vin  "http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#" >  
   <!ENTITY food "http://www.w3.org/TR/2004/REC-owl-guide-20040210/food#" > ]>  

在声明这些实体后，可以将“&vin;merlot”作为“http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#merlot”的简写。  

所以上述命名空间可写为：  

<?xml version="1.0"?>  
<!DOCTYPE rdf:RDF [  
   <!ENTITY vin  "http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#" >  
   <!ENTITY food "http://www.w3.org/TR/2004/REC-owl-guide-20040210/food#" > ]>  
<rdf:RDF   
   xmlns     ="&vin;"   
   xmlns:vin ="&vin;"   
   xml:base  ="&vin;"   
   xmlns:food="&food;"  
   xmlns:owl ="http://www.w3.org/2002/07/owl#"  
   xmlns:rdf ="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"  
   xmlns:xsd ="http://www.w3.org/2001/XMLSchema#">  
###4.本体头部
建立了命名空间后，接下来我们通常要在owl:Ontology标签里给出一组关于本体的声明。这些标签支持一些重要的常务工作比如注释、版本控制以及其他本体的嵌入等。  

 <owl:Ontology rdf:about="">   
   <rdfs:comment>An example OWL ontology</rdfs:comment>  
   <owl:priorVersion rdf:resource="http://www.w3.org/TR/2003/PR-owl-guide-20031215/wine"/>    
   <owl:imports rdf:resource="http://www.w3.org/TR/2004/REC-owl-guide-20040210/food"/>   
   <rdfs:label>Wine Ontology</rdfs:label>   
   ...  

owl:Ontology元素是用来收集关于当前文档的OWL元数据的。  

rdf:about属性为本体提供一个名称或引用。根据标准，当rdf:about属性的值为""时，本体的名称是owl: Ontology元素的基准URI。典型地，这是一个包含本体的文档的URI。在使用了xml:base的上下文中则是一个特殊情况，这时owl: Ontology元素的基准URI也许会被设为其他URI。  

rdfs:comment提供了显然必须的为本体添加注解的能力。  

owl:priorVersion是一个为用于本体的版本控制系统提供相关信息（hook）的标准标签。  

owl:imports提供了一种嵌入机制，接受一个用rdf:resource属性标识的参数。导入另一个本体将把那个本体中的全部声引入到当前本  体中。为了充分利用好这一机制，通常要与命名空间声明结合使用。请注意这两种机制的区别：命名空间声明提供的是一种方便对其他本体定义的名称进行引用的方法。概念上，owl:imports用于表明包含目标本体中的声明。在导入另一个本体02时，在02中导入的其他本体也将被导入。  

rdfs:label对本体进行自然语言标注。
###5.基本元素
#####1> 简单的类和个体
使用本体是为了用它进行关于个体的推理。为了在一种有效的方式下做到这一点，我们需要一种机制来描述个体所属的类以及这些个
体通过类成员关系而继承得到的属性。尽管我们总能为个体声明特定的属性，但是本体的大部分能力在于"基于类的推理"。  

当我们希望强调区分一个类是作为对象还是作为包含元素的集合。称由属于某个类的个体所构成的集合为该类的外延(extension)。  

1>>简单的具名类－－Class, rdfs:subClassOf
一个领域中的最基本概念应分别对应于各个分类层次树的根。OWL中的所有个体都是类owl:Thing的成员。因此，各个用户自定义的类
都隐含地是 owl:Thing的一个子类。要定义特定领域的根类，只需将它们声明为一个具名类（named class）即可。OWL也可以定义空
类，owl:Nothing。  
 
定义可以是增量的和分布式的：  
语法<owl:Class rdf:ID="Region"/> 被用于引入一个名称（作为定义的一部分）。该rdf:ID属性（attribute） 类似于XML中的ID属
性。在这一文档中，我们现在可以用#Region来引用Region类，例如 rdf:resource="#Region"。而其他的本体可以通
过"http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#Region"这一完整形式来引用该名称。  
 
语法<owl:Class rdf:about="Region"/>来扩展对一个资源的定义。语法 rdf:about="&ont;#x" 的使用在分布式本体的创建中是一个
关键要素。它允许导入x类的定义并对它进行扩展，而不需修改源定义文档，从而支持增量构建更大的本体。  

rdfs:subClassOf是用于类的基本分类构造符。它将一个较具体的类与一个较一般的类关联。如果X是Y的一个子类（subclass），那么
X的每个实例同时也都是Y的实例。rdfs:subClassOf关系是可传递的，即如果X是Y的子类，而Y又是Z的子类，那么X就是Z的子类。  

 <owl:Class rdf:ID="Wine">   
   <rdfs:subClassOf rdf:resource="&food;PotableLiquid"/>   
   <rdfs:label xml:lang="en">wine</rdfs:label>   
   <rdfs:label xml:lang="fr">vin</rdfs:label>   
   ...    
 </owl:Class>   

rdfs:label是可选的，它为该类提供一个人类可读的名称。负责呈现的工具可以利用这个元素。“lang”属性为多语言提供了支持。  

一个label（标号）就像一个注释，不向本体的逻辑解释添加任何内容。  

2>>个体  
要引入一个个体（individual），只需将它们声明为某个类的成员。  

 <owl:Class rdf:ID="WineGrape">  
   <rdfs:subClassOf rdf:resource="&food;Grape" />  
 </owl:Class>   
 <WineGrape rdf:ID="CabernetSauvignonGrape" />  

关于OWL中类与个体的区别，有一些重要的问题。一个类仅是一个名称和一些描述某集合内个体的属性；而个体是该集合的成员。因此
，类应自然地对应于与某论域中的事物的出现集合，而个体应对应于可被归入这些类的实际的实体。  

#####2>简单属性
1>>定义属性－－ObjectProperty, DatatypeProperty, rdfs:subPropertyOf, rdfs:domain, rdfs:range  

一个属性是一个二元关系。有两种类型的属性：    
 * 数据类型属性（datatype properties），类实例与RDF文字或XML Schema数据类型间的关系。  
 * 对象属性（object properties），两个类的实例间的关系。注意：对象属性这个名称并不是要反映与RDF术语rdf:object的联系。  

 <owl:ObjectProperty rdf:ID="hasWineDescriptor">  
   <rdfs:domain rdf:resource="#Wine" />  
   <rdfs:range  rdf:resource="#WineDescriptor" />  
 </owl:ObjectProperty>   
 <owl:ObjectProperty rdf:ID="hasColor">  
   <rdfs:subPropertyOf rdf:resource="#hasWineDescriptor" />  
   <rdfs:range rdf:resource="#WineColor" />  
   ...  
 </owl:ObjectProperty>   

为同一属性声明多个定义域表明该属性的定义域是所有这些类的交集（多个值域声明也类似这样）。属性也可以像类一样按照层次结
构来组织。  

介绍locatedIn属性，它将事物和事物所在的地区相关联：  
 <owl:ObjectProperty rdf:ID="locatedIn">  
   ...  
   <rdfs:domain rdf:resource="http://www.w3.org/2002/07/owl#Thing" />  
   <rdfs:range rdf:resource="#Region" />  
 </owl:ObjectProperty>  

该定义域定义允许任何事物被值域某个区域中，包括该区域自身。这一关系的传递的组合本质上构建了一个包含子区域和事物的地理
网络。没有包含其他事物于其中的那些事物可以属于任意类,而包含其他事物或者区域的那些事物则必须是区域。  
示例：  

 <owl:ObjectProperty rdf:ID="madeFromGrape">   
   <rdfs:domain rdf:resource="#Wine"/>  
   <rdfs:range rdf:resource="#WineGrape"/>   
 </owl:ObjectProperty>  
 <owl:Class rdf:ID="Wine">      
   <rdfs:subClassOf rdf:resource="&food;PotableLiquid"/>      
   
   <rdfs:subClassOf>
      <owl:Restriction>  
         <owl:onProperty rdf:resource="#madeFromGrape"/>  
         <owl:minCardinality rdf:datatype="&xsd;nonNegativeInteger">1</owl:minCardinality>  
      </owl:Restriction>  
   </rdfs:subClassOf>  
   ...    
 </owl:Class>  
第二个子类属性元素中定义了一个无名类（unnamed class），该无名类代表至少具有一个madeFromGrape属性的事物集合。我们称这
些类为匿名类。在Wine类的定义中包含该限定表明属于Wine类的事物，也是该匿名类的成员。也就是说，任何葡萄酒都必须参与至少
一个madeFromGrape关系。
2>>属性和数据类型
根据是将个体关联到个体、还是将个体关联到数据类型，我们可以区分两类属性：前者称为对象属性；后者称为数据类型属性。数据
类型属性的值域范围是RDF文字或者是XML Schema数据类型中定义的那些简单类型。
OWL使用XML Schema内嵌数据类型中的大部分。对这些数据类型的引用是通过对http://www.w3.org/2001/XMLSchema这个URI引用。
3>属性特性
1>>TransitiveProperty 传递属性
如果一个属性P被声明为传递属性，那么对于任意的x,y和z： P(x,y)与P(y,z) 蕴含 P(x,z)
2>>SymmetricProperty 对称属性
如果一个属性P被声明为对称属性，那么对于任意的x和y： P(x,y)当且仅当P(y,x)
示例： 
 <owl:ObjectProperty rdf:ID="adjacentRegion">
   <rdf:type rdf:resource="&owl;SymmetricProperty" />
   <rdfs:domain rdf:resource="#Region" />
   <rdfs:range rdf:resource="#Region" />
 </owl:ObjectProperty>
 <Region rdf:ID="MendocinoRegion">
   <locatedIn rdf:resource="#CaliforniaRegion" />
   <adjacentRegion rdf:resource="#SonomaRegion" />
 </Region>
3>>FunctionalProperty 函数型属性
如果一个属性P被标记为函数型属性，那么对于所有的x, y, 和z:  P(x,y)与P(x,z) 蕴含 y = z 
示例：
 <owl:Class rdf:ID="VintageYear" /> 
 <owl:ObjectProperty rdf:ID="hasVintageYear">
   <rdf:type rdf:resource="&owl;FunctionalProperty" />
   <rdfs:domain rdf:resource="#Vintage" />
   <rdfs:range  rdf:resource="#VintageYear" />
 </owl:ObjectProperty>
一种葡萄酒有着一个特定的制造年份。也即，一个给定的 Vintage个体只能使用hasVintageYear属性与单独一个年份相关联。
4>>inverseOf 逆属性
如果一个属性P1被标记为属性P2的逆, 那么对于所有的x 和 y:  P1(x,y) 当且仅当P2(y,x)
请注意owl:inverseOf的语法，它仅仅使用一个属性名作为参数。A 当且仅当B意思是 (A蕴含B)并且(B蕴含A). 
示例：
 <owl:ObjectProperty rdf:ID="hasMaker">
   <rdf:type rdf:resource="&owl;FunctionalProperty" />
 </owl:ObjectProperty>  
 <owl:ObjectProperty rdf:ID="producesWine">
   <owl:inverseOf rdf:resource="#hasMaker" />
 </owl:ObjectProperty>
各种葡萄酒都有制造商，这些制造商在Wine类的定义中被限制为酿酒厂（Winery）。而每个酿酒厂生产的酒均以该酿酒厂为制造商。
5>>InverseFunctionalProperty－－反函数属性
如果一个属性P被标记为反函数型的，那么对于所有的x, y和z:  P(y,x)与P(z,x) 蕴含 y = z 
示例：
 <owl:ObjectProperty rdf:ID="hasMaker" />
 <owl:ObjectProperty rdf:ID="producesWine">
   <rdf:type rdf:resource="&owl;InverseFunctionalProperty" />
   <owl:inverseOf rdf:resource="#hasMaker" />
 </owl:ObjectProperty>
producesWine属性是反函数型属性。因为一个函数型属性的逆必定是反函数型的。反函数型属性的值域中的元素可以看成是在数据库
意上定义一个唯一的键值。owl:InverseFunctional意味着属性的值域中的元素为定义域中的每个元素提供了一个唯一的标识。
4>属性限制－－在一个明确的上下文owl:Restriction中限制属性的值域,owl:onProperty元素指出了受限制的属性。
1>>allValuesFrom, someValuesFrom
owl:allValuesFrom属性限制要求：对于每一个有指定属性实例的类实例，该属性的值必须是由owl:allValuesFrom从句指定的类的成
员。owl:someValuesFrom限制与之相似。这两种限制形式间的不同就是全称量词与存在量词间的不同。
示例：
<owl:Class rdf:ID="Wine">
   <rdfs:subClassOf rdf:resource="&food;PotableLiquid" />
   ...
   <rdfs:subClassOf>
     <owl:Restriction>
       <owl:onProperty rdf:resource="#hasMaker" />
       <owl:allValuesFrom rdf:resource="#Winery" />
     </owl:Restriction>
   </rdfs:subClassOf>
   
   ...
 </owl:Class>
Wine的制造商必须是Winery。allValuesFrom限制仅仅应用在Wine的hasMaker属性上。
在上个例子中，如果我们用owl:someValuesFrom替换owl:allValuesFrom，那就意味着至少有一个Wine类实例的hasMaker属性是指向一
个Winery类的个体的。
2>>基数限制－－使用owl:cardinality，这一约束允许对一个关系中的元素数目作出精确的限制。
示例：
 <owl:Class rdf:ID="Vintage"> 
   <rdfs:subClassOf>
     <owl:Restriction>
       <owl:onProperty rdf:resource="#hasVintageYear"/> 
       <owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1</owl:cardinality>
     </owl:Restriction>
   </rdfs:subClassOf>
 </owl:Class>
我们标识hasVintageYear属性为一个函数型属性，也即意味着每个Vintage有至多一个VintageYear。而如果对Vintage类的
hasVintageYear属性使用基数限制则是对其作出了更强的断言，它表明了每个Vintage有恰好一个VintageYear。
值域限制在0和1的基数表达式(Cardinality expressions)是OWL Lite的一部分。这使得用户能够表示“至少一个”，“不超过一个”
，和“恰好一个”这几种意思。OWL DL中还允许使用除0与1以外的正整数值。owl:maxCardinality能够用来指定一个上界。
owl:minCardinality能够用来指定一个下界。使用二者的组合就能够将一个属性的基数限制为一个数值区间。
3>>hasValue [OWL DL]
hasValue 使得我们能够根据“特定的”属性值的存在来标识类。因此，一个个体只要至少有“一个”属性值等于hasValue的资源，这
一个体就是该类的成员。
示例：
 <owl:Class rdf:ID="Burgundy">
   ...
   <rdfs:subClassOf>
     <owl:Restriction>
       <owl:onProperty rdf:resource="#hasSugar" />
       <owl:hasValue rdf:resource="#Dry" />
     </owl:Restriction>
   </rdfs:subClassOf>
 </owl:Class>
这里我们声明了所有的Burgundy酒都是干(dry)的酒。也即，它们的hasSugar属性必须至少有一个是值等于Dry（干的）。
与allValuesFrom 和someValuesFrom类似，这是一个局部的限制。它仅仅对Burgundy类的hasSugar属性作出限制。


5.本体映射
为了让本体发挥最大的作用，就需要让本体得到充分的共享。为了使得在开发本体时尽可能的节省人力，就需要使得开发出的本体能
够被重用。更理想的情况是他们能够被组合使用。在开发一个本体的过程中，很多的精力都被投入到将类与属性联系起来以获取最大
的意义的工作上去了,意识到这一点也是很重要的。我们希望对类成员作出的断言较为简单同时又要求有广泛的和有用的含意在里面。
这也是在本体开发过程中最为困难的工作。如果你能够找到已经经过广泛使用和精炼的本体，那么采用它才有意义。
1>类和属性之间的等价关系－－equivalentClass, equivalentProperty
在食物本体中，我们现在想把在餐宴菜肴中对葡萄酒特点的描述与葡萄酒本体相联系起来。达到这一目的一种方法就是在食物本体中
定义一个类(&food;Wine)，然后在葡萄酒本体中将一个已有的类声明为与这个类是等价的。
 <owl:Class rdf:ID="Wine">
   <owl:equivalentClass rdf:resource="&vin;Wine"/>
 </owl:Class>
属性owl:equivalentClass被用来表示两个类有着完全相同的实例。但我们要注意，在OWL DL中，类仅仅代表着个体的集合而不是个体
本身。然而在OWL FULL中，我们能够使用owl:sameAs来表示两个类在各方面均完全一致。类似的，owl:equivalentProperty属性声明
表达属性的等同。
示例：
 <owl:Class rdf:ID="TexasThings">
   <owl:equivalentClass>
     <owl:Restriction>
       <owl:onProperty rdf:resource="#locatedIn" />
       <owl:someValuesFrom rdf:resource="#TexasRegion" />
     </owl:Restriction>
   </owl:equivalentClass>
 </owl:Class>
TexasThings指的是那些恰好位于Texas地区的事物。使用owl:equivalentClass 和使用rdfs:subClassOf 的不同就像必要条件和充要
条件的不同一样。如果是使用subClassOf的话，位于Texas地区的事物不一定是TexasThings。但是，如果使用owl:equivalentClass，
位于Texas地区的事物一定属于TexasThings类。
2>个体间的同一性z－－sameAs
描述个体之间相同的机制与描述类之间的相同的机制类似，仅仅只要将两个个体声明成一致的就可以了。
示例：
 <Wine rdf:ID="MikesFavoriteWine>
     <owl:sameAs rdf:resource="#StGenevieveTexasWhite" />
 </Wine>
要清楚，修饰（或引用）两个类用sameAs还是用equivalentClass效果是不同的。用sameAs的时候，把一个类解释为一个个体，就像在
OWL Full中一样，这有利于对本体进行分类。
3>不同的个体－－differentFrom, AllDifferent
这一机制提供了与sameAs相反的效果。
 <WineSugar rdf:ID="Dry" />
 
 <WineSugar rdf:ID="Sweet"> 
   <owl:differentFrom rdf:resource="#Dry"/>  
 </WineSugar> 
 
 <WineSugar rdf:ID="OffDry">
   <owl:differentFrom rdf:resource="#Dry"/> 
   <owl:differentFrom rdf:resource="#Sweet"/> 
 </WineSugar>
这是一种声明这三个值相互不同的方法。但在有些时候，更重要的是利用这些定义元素能把这种不同区别开来。
还有一种更便利的定义相互不同个体的机制。如下面申明红葡萄酒、白葡萄酒和玫瑰葡萄酒的例子。
 <owl:AllDifferent>
   <owl:distinctMembers rdf:parseType="Collection">
     <vin:WineColor rdf:about="#Red" />
     <vin:WineColor rdf:about="#White" />
     <vin:WineColor rdf:about="#Rose" />
   </owl:distinctMembers>
 </owl:AllDifferent>
注意，owl:distinctMembers属性声明只能和owl:AllDifferent属性声明一起结合使用。


6. 复杂类
1>集合运算符 intersectionOf,unionOf,complementOf
记住:OWL类外延是由个体组成的集合，而这些个体都是类的成员。OWL使用基本的集合操作算子来处理类的外延。
1>>交运算intersectionOf
 <owl:Class rdf:ID="WhiteWine">
   <owl:intersectionOf rdf:parseType="Collection">
     <owl:Class rdf:about="#Wine" />
     <owl:Restriction>
       <owl:onProperty rdf:resource="#hasColor" />
       <owl:hasValue rdf:resource="#White" />
     </owl:Restriction>
   </owl:intersectionOf>
 </owl:Class>
上面的语句说明WhiteWine恰好是类Wine与所有颜色是白色的事物的集合的交集。
(请注意：'rdf:parseType= "Collection"'是必需的语法元素。)
 <owl:Class rdf:about="#Burgundy">
   <owl:intersectionOf rdf:parseType="Collection">
     <owl:Class rdf:about="#Wine" />
     <owl:Restriction>
       <owl:onProperty rdf:resource="#locatedIn" />
       <owl:hasValue rdf:resource="#BourgogneRegion" />
     </owl:Restriction>
   </owl:intersectionOf>
 </owl:Class>
 <owl:Class rdf:ID="WhiteBurgundy">
   <owl:intersectionOf rdf:parseType="Collection">
     <owl:Class rdf:about="#Burgundy" />
     <owl:Class rdf:about="#WhiteWine" />
   </owl:intersectionOf> 
 </owl:Class>
2>>并运算unionOf
 <owl:Class rdf:ID="Fruit">
   <owl:unionOf rdf:parseType="Collection">
     <owl:Class rdf:about="#SweetFruit" />
     <owl:Class rdf:about="#NonSweetFruit" />
   </owl:unionOf>
 </owl:Class>
3>>补运算complementOf
complementOf结构从某个论域(domain of discourse)选出不属于某个类的所有个体。通常它将指向一个非常大的个体集合：
 <owl:Class rdf:ID="NonFrenchWine">
   <owl:intersectionOf rdf:parseType="Collection">
     <owl:Class rdf:about="#Wine"/>
     
     <owl:Class>
       <owl:complementOf>
         <owl:Restriction>
           <owl:onProperty rdf:resource="#locatedIn" />
           <owl:hasValue rdf:resource="#FrenchRegion" />
         </owl:Restriction>
       </owl:complementOf>
     </owl:Class>
   </owl:intersectionOf>
 </owl:Class>
2>枚举类 oneOf 
OWL提供了一种通过直接枚举类的成员的方法来描述类。这是通过使用oneOf结构来完成。特别地，这个定义完整地描述了类的外延，
因此任何其他个体都不能被声明为属于这个类。oneOf结构的每一个元素都必须是一个有效声明的个体。一个个体必须属于某个类。
 <owl:Class rdf:ID="WineColor">
   <rdfs:subClassOf rdf:resource="#WineDescriptor"/>
   <owl:oneOf rdf:parseType="Collection">
     <owl:Thing rdf:about="#White"/>
     <owl:Thing rdf:about="#Rose"/>
     <owl:Thing rdf:about="#Red"/>
   </owl:oneOf>
 </owl:Class>
3>不相交类 disjointWith
使用owl:disjointWith构造子可以表达一组类是不相交的。它保证了属于某一个类的个体不能同时又是另一个指定类的实例。
 <owl:Class rdf:ID="Pasta">
   <rdfs:subClassOf rdf:resource="#EdibleThing"/>
   <owl:disjointWith rdf:resource="#Meat"/>
   <owl:disjointWith rdf:resource="#Fowl"/>
   <owl:disjointWith rdf:resource="#Seafood"/>
   <owl:disjointWith rdf:resource="#Dessert"/>
   <owl:disjointWith rdf:resource="#Fruit"/>
 </owl:Class>
注意它只声明了Pasta与其它所有类是不相交的。例如，它并没有保证Meat和Fruit是不相交的。为了声明一组类是互不相交的，我们
必须对每两个类都使用owl:disjointWith来声明。
当n很大时，我们可以使用另一些方法以避免声明的数目按二次方增长。工作原理如下：我们描述一个父类，它的元素有一个基数等于
一的属性。接着，对于这个父类的每一个子类，我们都要求这个子类的实例的这一属性必须具有一个唯一的值。在这种情况下，各个
不同子类就不可能有共同的成员了。
7.本体的版本控制
本体和软件一样需要维护，因此它们将随着时间的推移而改变。在一个owl:Ontology元素内，链接到一个以前定义的本体版本是可能
的。属性owl:priorVersion被用来提供这种链接，并能用它跟踪一个本体的版本历史。
 <owl:Ontology rdf:about=""> 
   ...
   <owl:priorVersion rdf:resource="http://www.w3.org/TR/2003/CR-owl-guide-20030818/wine"/>    
   ...
 </owl:Ontology>
本体版本可能彼此互不兼容，例如，一个本体以前的版本可能包含与现在版本中的陈述相矛盾的陈述。在一个owl:Ontology元素中，
我们使用owl:backwardCompatibleWith和owl:incompatibleWith这些属性来指出本体版本是兼容还是不兼容以前的版本。如果没有进
行owl:backwardCompatibleWith声明，那么我们假定就不存在兼容性。除了上面讲到的两个属性，还有一个属性 owl:versionInfo适
用与版本控制系统，它提供了一些相关信息（hook）。和前面三个属性相反的是，owl:versionInfo的客体是一个文字值（literal）
，这一属性除了可以用来注释本体之外还可以用来注释类和属性。
OWL Full提供的表示能力能够对一个类进行任何类型的声明，也即可以声明一个类可以是另一个类的实例，或者一个类（不是它的实
例）有一个属性和一个对应的属性值。这一框架就能被用来为版本跟踪信息建立一个由类和属性构成的本体。OWL的名称间中包括了两
个预定义的类owl:DeprecatedClass和 owl:DeprecatedProperty来完成这个目的。他们被用来指明某个类或属性在未来发布的版本中
可能以一种不兼容的方式发生变化。